{"version":3,"sources":["webpack://importHTML/webpack/universalModuleDefinition","webpack://importHTML/webpack/bootstrap","webpack://importHTML/./src/utils.js","webpack://importHTML/(webpack)/buildin/global.js","webpack://importHTML/./src/process-tpl.js","webpack://importHTML/./src/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;;;;;;;;AC9CA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;;ACnBwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEO;AACP;AACA;AACO;AACP;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,GAAG;AACH,wDAAwD;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,OAAO;;;AAGP,iBAAiB,sCAAa,QAAQ;;AAEtC;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;AC3JA;AAAA;AAAiE;AACO;;AAExE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,kBAAkB,EAAE,IAAI;AACzE;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wBAAwB,oBAAoB,yBAAyB,SAAS,KAAK,eAAe;AAClG;AACA,IAAI;AACJ;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAa;AACxB,IAAI;AACJ;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,sCAAa;AACxB,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,0CAA0C,UAAU;AACpD,sDAAsD,UAAU;;AAEhE,QAAQ,KAAsC,EAAE,EAE3C;;AAEL;AACA,KAAK,wCAAe;;AAEpB;AACA;AACA,cAAc,mBAAmB,EAAE,aAAa,GAAG,mCAAmC;AACtF,MAAM;AACN,8DAA8D,UAAU;AACxE;AACA;;AAEA,2BAA2B,sCAAa;AACxC;;AAEA,KAAK;AACL;AACA;AACA,cAAc,mBAAmB,EAAE,aAAa,GAAG,mCAAmC;AACtF,MAAM;AACN,oDAAoD,UAAU;AAC9D;AACA;;AAEA;;AAEA,QAAQ,KAAsC,EAAE,EAI3C;AACL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEe;;AAEf;AACA;AACA;;AAEA,UAAU,mCAAmC,GAAG,UAAU;;AAE1D;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS,uCAAuC;;AAEhD;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,EAAE;AACF;AACA;AACA","file":"import-html-entry.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"importHTML\"] = factory();\n\telse\n\t\troot[\"importHTML\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","let firstGlobalProp, secondGlobalProp, lastGlobalProp;\nexport function getGlobalProp() {\n\tlet cnt = 0;\n\tlet lastProp;\n\tlet hasIframe = false;\n\tfor (let p in global) {\n\t\tif (!global.hasOwnProperty(p))\n\t\t\tcontinue;\n\n\t\t// 遍历 iframe，检查 window 上的属性值是否是 iframe，是则跳过后面的 first 和 second 判断\n\t\tfor (let i = 0; i < window.frames.length; i++) {\n\t\t\tconst frame = window.frames[i];\n\t\t\tif (frame === global[p]) {\n\t\t\t\thasIframe = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!hasIframe && (cnt === 0 && p !== firstGlobalProp || cnt === 1 && p !== secondGlobalProp))\n\t\t\treturn p;\n\t\tcnt++;\n\t\tlastProp = p;\n\t}\n\tif (lastProp !== lastGlobalProp)\n\t\treturn lastProp;\n}\n\nexport function noteGlobalProps() {\n\t// alternatively Object.keys(global).pop()\n\t// but this may be faster (pending benchmarks)\n\tfirstGlobalProp = secondGlobalProp = undefined;\n\tfor (let p in global) {\n\t\tif (!global.hasOwnProperty(p))\n\t\t\tcontinue;\n\t\tif (!firstGlobalProp)\n\t\t\tfirstGlobalProp = p;\n\t\telse if (!secondGlobalProp)\n\t\t\tsecondGlobalProp = p;\n\t\tlastGlobalProp = p;\n\t}\n\treturn lastGlobalProp;\n}\n\nexport function getInlineCode(match) {\n\tconst start = match.indexOf('>') + 1;\n\tconst end = match.lastIndexOf('<');\n\treturn match.substring(start, end);\n}\n\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { getInlineCode } from './utils';\nvar ALL_SCRIPT_REGEX = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi;\nvar SCRIPT_TAG_REGEX = /<(script)\\s+((?!type=('|')text\\/ng-template\\3).)*?>.*?<\\/\\1>/i;\nvar SCRIPT_SRC_REGEX = /.*\\ssrc=('|\")(\\S+)\\1.*/;\nvar SCRIPT_ENTRY_REGEX = /.*\\sentry\\s*.*/;\nvar LINK_TAG_REGEX = /<(link)\\s+.*?>/gi;\nvar LINK_IGNORE_REGEX = /.*ignore\\s*.*/;\nvar STYLE_TAG_REGEX = /<style[^>]*>[\\s\\S]*?<\\/style>/gi;\nvar STYLE_TYPE_REGEX = /\\s+rel=(\"?|'?)stylesheet\\1.*/;\nvar STYLE_HREF_REGEX = /.*\\shref=('?|\"?)(\\S+)\\1.*/;\nvar STYLE_IGNORE_REGEX = /<style(\\s+|\\s+.+\\s+)ignore(\\s*|\\s+.*)>/i;\nvar HTML_COMMENT_REGEX = /<!--([\\s\\S]*?)-->/g;\nvar SCRIPT_IGNORE_REGEX = /<script(\\s+|\\s+.+\\s+)ignore(\\s*|\\s+.*)>/i;\n\nfunction hasProtocol(url) {\n  return url.startsWith('//') || url.startsWith('http://') || url.startsWith('https://');\n}\n\nfunction getBaseDomain(url) {\n  return url.endsWith('/') ? url.substr(0, url.length - 1) : url;\n}\n\nexport var genLinkReplaceSymbol = function genLinkReplaceSymbol(linkHref) {\n  return \"<!-- link \".concat(linkHref, \" replaced by import-html-entry -->\");\n};\nexport var genScriptReplaceSymbol = function genScriptReplaceSymbol(scriptSrc) {\n  return \"<!-- script \".concat(scriptSrc, \" replaced by import-html-entry -->\");\n};\nexport var inlineScriptReplaceSymbol = \"<!-- inline scripts replaced by import-html-entry -->\";\nexport var genIgnoreAssetReplaceSymbol = function genIgnoreAssetReplaceSymbol(url) {\n  return \"<!-- ignore asset \".concat(url || 'file', \" replaced by import-html-entry -->\");\n};\n/**\n * parse the script link from the template\n * 1. collect stylesheets\n * 2. use global eval to evaluate the inline scripts\n *    see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function#Difference_between_Function_constructor_and_function_declaration\n *    see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Do_not_ever_use_eval!\n * @param tpl\n * @param domain\n * @stripStyles whether to strip the css links\n * @returns {{template: void | string | *, scripts: *[], entry: *}}\n */\n\nexport default function processTpl(tpl, domain) {\n  var scripts = [];\n  var styles = [];\n  var entry = null;\n  var template = tpl\n  /*\n  remove html comment first\n  */\n  .replace(HTML_COMMENT_REGEX, '').replace(LINK_TAG_REGEX, function (match) {\n    /*\n    change the css link\n    */\n    var styleType = !!match.match(STYLE_TYPE_REGEX);\n\n    if (styleType) {\n      var styleHref = match.match(STYLE_HREF_REGEX);\n      var styleIgnore = match.match(LINK_IGNORE_REGEX);\n\n      if (styleHref) {\n        var container = document.createElement('div')\n        container.innerHTML = styleHref.input\n        var href = styleHref && container.childNodes[0].href;\n        var newHref = href;\n\n        if (href && !hasProtocol(href)) {\n          // 处理一下使用相对路径的场景\n          newHref = getBaseDomain(domain) + (href.startsWith('/') ? href : \"/\".concat(href));\n        }\n\n        if (styleIgnore) {\n          return genIgnoreAssetReplaceSymbol(newHref);\n        }\n\n        styles.push(newHref);\n        return genLinkReplaceSymbol(newHref);\n      }\n    }\n\n    return match;\n  }).replace(STYLE_TAG_REGEX, function (match) {\n    if (STYLE_IGNORE_REGEX.test(match)) {\n      return genIgnoreAssetReplaceSymbol('style file');\n    }\n\n    return match;\n  }).replace(ALL_SCRIPT_REGEX, function (match) {\n    var scriptIgnore = match.match(SCRIPT_IGNORE_REGEX); // in order to keep the exec order of all javascripts\n    // if it is a external script\n\n    if (SCRIPT_TAG_REGEX.test(match)) {\n      /*\n      collect scripts and replace the ref\n      */\n      var matchedScriptEntry = match.match(SCRIPT_ENTRY_REGEX);\n      var matchedScriptSrcMatch = match.match(SCRIPT_SRC_REGEX);\n      var container = document.createElement('div')\n      container.innerHTML = match\n      var matchedScriptSrc = container.childNodes[0].src\n      // var matchedScriptSrc = matchedScriptSrcMatch && matchedScriptSrcMatch[2];\n\n      if (entry && matchedScriptEntry) {\n        throw new SyntaxError('You should not set multiply entry script!');\n      } else {\n        // append the domain while the script not have an protocol prefix\n        if (matchedScriptSrc && !hasProtocol(matchedScriptSrc)) {\n          matchedScriptSrc = getBaseDomain(domain) + (matchedScriptSrc.startsWith('/') ? matchedScriptSrc : \"/\".concat(matchedScriptSrc));\n        }\n\n        entry = entry || matchedScriptEntry && matchedScriptSrc;\n      }\n\n      if (scriptIgnore) {\n        return genIgnoreAssetReplaceSymbol(matchedScriptSrc || 'js file');\n      }\n\n      if (matchedScriptSrc) {\n        scripts.push(matchedScriptSrc);\n        return genScriptReplaceSymbol(matchedScriptSrc);\n      }\n\n      return match;\n    } else {\n      if (scriptIgnore) {\n        return genIgnoreAssetReplaceSymbol('js file');\n      } // if it is an inline script\n\n\n      var code = getInlineCode(match); // remove script blocks when all of these lines are comments.\n\n      var isPureCommentBlock = code.split(/[\\r\\n]+/).every(function (line) {\n        return !line.trim() || line.trim().startsWith('//');\n      });\n\n      if (!isPureCommentBlock) {\n        scripts.push(match);\n      }\n\n      return inlineScriptReplaceSymbol;\n    }\n  });\n  scripts = scripts.filter(function (script) {\n    // filter empty script\n    return !!script;\n  });\n  return {\n    template: template,\n    scripts: scripts,\n    styles: styles,\n    // set the last script as entry if have not set\n    entry: entry || scripts[scripts.length - 1]\n  };\n}","import processTpl, { genLinkReplaceSymbol } from './process-tpl';\nimport { getGlobalProp, getInlineCode, noteGlobalProps } from './utils';\n\nconst styleCache = {};\nconst scriptCache = {};\nconst embedHTMLCache = {};\nconst fetch = window.fetch.bind(window);\n\nfunction getDomain(url) {\n\ttry {\n\t\t// URL 构造函数不支持使用 // 前缀的 url\n\t\tconst href = new URL(url.startsWith('//') ? `${location.protocol}${url}` : url);\n\t\treturn href.origin;\n\t} catch (e) {\n\t\treturn '';\n\t}\n}\n\n/**\n * convert external css link to inline style for performance optimization\n * @param template\n * @param styles\n * @return embedHTML\n */\nfunction getEmbedHTML(template, styles) {\n\n\tlet embedHTML = template;\n\n\treturn getExternalStyleSheets(styles)\n\t\t.then(styleSheets => {\n\t\t\tembedHTML = styles.reduce((html, styleSrc, i) => {\n\t\t\t\thtml = html.replace(genLinkReplaceSymbol(styleSrc), `<style>/* ${styleSrc} */${styleSheets[i]}</style>`);\n\t\t\t\treturn html;\n\t\t\t}, embedHTML);\n\t\t\treturn embedHTML;\n\t\t});\n}\n\n// for prefetch\nfunction getExternalStyleSheets(styles) {\n\treturn Promise.all(styles.map(styleLink => {\n\t\t\tif (styleLink.startsWith('<')) {\n\t\t\t\t// if it is inline style\n\t\t\t\treturn getInlineCode(styleLink);\n\t\t\t} else {\n\t\t\t\t// external styles\n\t\t\t\treturn styleCache[styleLink] ||\n\t\t\t\t\t(styleCache[styleLink] = fetch(styleLink).then(response => response.text()));\n\t\t\t}\n\n\t\t},\n\t));\n}\n\n// for prefetch\nfunction getExternalScripts(scripts) {\n\treturn Promise.all(scripts.map(script => {\n\t\t\tif (script.startsWith('<')) {\n\t\t\t\t// if it is inline script\n\t\t\t\treturn getInlineCode(script);\n\t\t\t} else {\n\t\t\t\t// external script\n\t\t\t\treturn scriptCache[script] ||\n\t\t\t\t\t(scriptCache[script] = fetch(script).then(response => response.text()));\n\t\t\t}\n\t\t},\n\t));\n}\n\nfunction execScripts(entry, scripts, proxy = window) {\n\n\treturn getExternalScripts(scripts)\n\t\t.then(scriptsText => {\n\n\t\t\twindow.proxy = proxy;\n\t\t\tconst geval = eval;\n\n\t\t\tfunction exec(scriptSrc, inlineScript, resolve) {\n\n\t\t\t\tconst markName = `Evaluating script ${scriptSrc}`;\n\t\t\t\tconst measureName = `Evaluating Time Consuming: ${scriptSrc}`;\n\n\t\t\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\t\t\tperformance.mark(markName);\n\t\t\t\t}\n\n\t\t\t\tif (scriptSrc === entry) {\n\t\t\t\t\tnoteGlobalProps();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// bind window.proxy to change `this` reference in script\n\t\t\t\t\t\tgeval(`;(function(window){;${inlineScript}\\n}).bind(window.proxy)(window.proxy);`);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(`error occurs while executing the entry ${scriptSrc}`);\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst exports = proxy[getGlobalProp()] || {};\n\t\t\t\t\tresolve(exports);\n\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// bind window.proxy to change `this` reference in script\n\t\t\t\t\t\tgeval(`;(function(window){;${inlineScript}\\n}).bind(window.proxy)(window.proxy);`);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tconsole.error(`error occurs while executing ${scriptSrc}`);\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\t\t\tperformance.measure(measureName, markName);\n\t\t\t\t\tperformance.clearMarks(markName);\n\t\t\t\t\tperformance.clearMeasures(measureName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction schedule(i, resolvePromise) {\n\n\t\t\t\tif (i < scripts.length) {\n\t\t\t\t\tconst scriptSrc = scripts[i];\n\t\t\t\t\tconst inlineScript = scriptsText[i];\n\n\t\t\t\t\texec(scriptSrc, inlineScript, resolvePromise);\n\t\t\t\t\tschedule(i + 1, resolvePromise);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new Promise(resolve => schedule(0, resolve));\n\t\t});\n}\n\nexport default function importHTML(url) {\n\n\treturn embedHTMLCache[url] || (embedHTMLCache[url] = fetch(url)\n\t\t.then(response => response.text())\n\t\t.then(html => {\n\n\t\t\tconst { template, scripts, entry, styles } = processTpl(html, getDomain(url));\n\n\t\t\treturn getEmbedHTML(template, styles).then(embedHTML => ({\n\t\t\t\ttemplate: embedHTML,\n\t\t\t\tgetExternalScripts: () => getExternalScripts(scripts),\n\t\t\t\tgetExternalStyleSheets: () => getExternalStyleSheets(styles),\n\t\t\t\texecScripts: proxy => execScripts(entry, scripts, proxy),\n\t\t\t}));\n\t\t}));\n};\n\nexport function importEntry(entry) {\n\n\tif (!entry) {\n\t\tthrow new SyntaxError('entry should not be empty!');\n\t}\n\n\t// html entry\n\tif (typeof entry === 'string') {\n\t\treturn importHTML(entry);\n\t}\n\n\t// config entry\n\tif (Array.isArray(entry.scripts) || Array.isArray(entry.styles)) {\n\n\t\tconst { scripts = [], styles = [], html = '' } = entry;\n\n\t\treturn getEmbedHTML(html, styles).then(embedHTML => ({\n\t\t\ttemplate: embedHTML,\n\t\t\tgetExternalScripts: () => getExternalScripts(scripts),\n\t\t\tgetExternalStyleSheets: () => getExternalStyleSheets(styles),\n\t\t\texecScripts: proxy => execScripts(scripts[scripts.length - 1], scripts, proxy),\n\t\t}));\n\n\t} else {\n\t\tthrow new SyntaxError('entry scripts or styles should be array!');\n\t}\n}\n"],"sourceRoot":""}